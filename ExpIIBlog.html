<!doctype html>
<html>
<head>
	<meta charset="UTF-8">
	<title>My First Blog</title>
	<link rel="icon" type="image/x-icon" href="page_icon.ico"/>
</head>
<body>
	<h1 style="text-align: center">
		基础实验2——谈JavaScript中的class继承
	</h1>
	<p>
		&emsp;&emsp;众所周知，对于像C++、Java和C#这样的语言，其面向对象编程都绕不开类对象（以及模板）和实例对象两个概念。实例是类的具体化；而类则规定了其实例的成员变量、成员函数等，能够继承和派生，具有良好的封装。
	</p>
	<p>
		&emsp;&emsp;但是JavaScript对类和实例不作区分，即所有的对象在实际上都是实例。在我们想获得若干与某对象拥有相同结构的对象时，需采用“原型继承的方法”。简单地说，就是将已有的某个对象的所有属性（属性名与属性值）原封不动照搬到一个新对象中，再对取值不同的属性作相应修改。
	</p>
	<p>
		&emsp;&emsp;原型继承的方法有不少，在ES6中使用关键字的class的方法被引进，同时因其更简洁的形式和与C++等语言的写法相似而受到好评。其中，本次实验的第二小题，便需要我们对class继承有充分的理解。
	</p>
	<div>
		<p>class示例：</p>
		<p>class Example {</p>
		<p>&emsp;constructor(name) {</p>
		<p>&emsp;&emsp;this.name = name;</p>
		<p>&emsp;}</p>
		<p>&emsp;hello() {</p>
		<p>&emsp;&emsp;alert('Welcome, ' + this.name + '!');</p>
		<p>&emsp;}</p>
		<p>}</p>
	</div>
	<p>
		&emsp;&emsp;class的继承方式派生自使用构造函数创建对象的方法。在构造函数中，this指向创建的新对象，因此用this可定义新对象的所有属性。在原型链上，新对象的直接上游对象是构造函数f()的属性f.prototype,同时还定义了f.prototype具有属性constructor————重新指向函数f()本身。所以，class继承中class内部的constructor函数，应被等价地看作新对象的构造函数。除了定义成员函数的部分被移到外部之外，其他部分均与构造函数法中的构造函数保持一致。
	</p>
	<p>
		&emsp;&emsp;在解决第二小题的过程中，本人曾经掉进过几个坑。其一，便是在constructor中定义一函数，并在该函数内部使用关键词this。this关键词本就是JavaScript的经典大坑,判断this的指向经常是需要解决的难题。在当前情形下，对于在constructor内部定义的函数，它不是任何非固有对象的方法，更不是f.prototype的方法，所以它只会指向全局对象window(非严格模式)或者undefined(严格模式)，根本无法获取或更改新对象的任何属性。
	</p>
	<p>
		&emsp;&emsp;其二，是在定义新对象时漏掉new关键字。不管是构造函数法还是class方法，忽略new关键字后的构造函数就不再具有构造函数的功能，退化为一般的函数。所以，内部的this再次视情况默认指向undefined或者window，造成程序报错，或者仅仅是给全局对象添加了几个属性。
	</p>
	<p>
		&emsp;&emsp;其三，在generator中嵌套调用自身。该错误和class关系不大，无论在什么地方，generator的嵌套调用似乎都是不被允许的。要使其能实现上述效果，好的办法是在generator内部按需求定义一函数，使该函数代替generator进行嵌套调用，返回结果序列给generator，最后才是根据返回的序列逐个进行yield操作。
	</p>
	<p>
		&emsp;&emsp;最后，关于this关键字在不同情形下的指向问题，目前我自己仍然没有彻底理解。之后，我还需要将它拎出来单独进行分情况讨论和梳理。
</body>
<style type="text/css">
	div{
		position: relative;
		left:30%;
		border-radius: 10px;
		border-color: grey;
		line-height: 40%;
		margin-top: 5px;
		margin-bottom: 5px;
	}
</style>
</html>